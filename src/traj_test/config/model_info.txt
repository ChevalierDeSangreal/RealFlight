============================================================
TrackVer6 TFLite Model Information
============================================================

模型结构:
  输入维度: 130
  输出维度 (动作维度): 4
  隐藏层: [128, 128]
  激活函数: ReLU (隐藏层), Tanh (输出层)

缓冲区配置:
  动作-状态缓冲区大小: 10
  动作重复: 10 steps

环境配置:
  max_steps_in_episode: 1000
  dt: 0.01
  delay: 0.03
  action_penalty_weight: 0.5
  target_height: 2.0
  target_init_distance_min: 0.5
  target_init_distance_max: 1.5
  target_speed_max: 1.0
  reset_distance: 100.0
  max_speed: 20.0

============================================================
C++部署说明:
============================================================

1. 输入格式:
   - 输入是一个长度为130的浮点数数组
   - 格式: [obs_0 + action_0, obs_1 + action_1, ..., obs_9 + action_9]
   - 每个元素包含观测和动作的拼接

2. 输出格式:
   - 输出是一个长度为4的浮点数数组
   - 表示四旋翼的控制指令
   - 输出范围: [-1, 1] (经过tanh激活)

3. 推理流程:
   - 维护一个大小为10的动作-状态缓冲区
   - 每10个时间步获取一次新动作
   - 将缓冲区展平为130维向量作为网络输入
   - 网络输出4维动作向量

4. TFLite C++ API使用示例:
   ```cpp
   // 加载模型
   auto model = tflite::FlatBufferModel::BuildFromFile("trackVer6_policy.tflite");
   tflite::ops::builtin::BuiltinOpResolver resolver;
   tflite::InterpreterBuilder builder(*model, resolver);
   std::unique_ptr<tflite::Interpreter> interpreter;
   builder(&interpreter);
   interpreter->AllocateTensors();

   // 准备输入
   float* input = interpreter->typed_input_tensor<float>(0);
   // 填充输入数据 (input[0] 到 input[129])

   // 推理
   interpreter->Invoke();

   // 获取输出
   float* output = interpreter->typed_output_tensor<float>(0);
   // 使用输出数据 (output[0] 到 output[3])
   ```

